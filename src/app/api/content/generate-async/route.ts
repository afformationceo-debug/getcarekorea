/**
 * Async Content Generation API
 *
 * POST /api/content/generate-async - Start async content generation
 *
 * This API starts content generation and waits for completion.
 * The client uses polling to check status while this runs.
 */

// Increase max duration to 5 minutes for content generation
export const maxDuration = 300;

import { NextRequest } from 'next/server';
import { createClient, createAdminClient } from '@/lib/supabase/server';
import {
  createSuccessResponse,
  createErrorResponse,
  APIError,
  ErrorCode,
  secureLog,
  validateRequired,
} from '@/lib/api/error-handler';
import {
  runContentPipeline,
  scoreContent,
} from '@/lib/content/generator';
import { runImagePipeline } from '@/lib/images/image-pipeline';
import type { Locale } from '@/lib/i18n/config';

// DB column name mapping
const DB_LOCALE_MAP: Record<string, string> = {
  'en': 'en',
  'ko': 'ko',
  'zh-TW': 'zh_tw',
  'zh-CN': 'zh_cn',
  'ja': 'ja',
  'th': 'th',
  'mn': 'mn',
  'ru': 'ru',
};

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    const adminSupabase = await createAdminClient();
    const { searchParams } = new URL(request.url);
    const locale = searchParams.get('locale') || 'en';

    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      throw new APIError(ErrorCode.UNAUTHORIZED);
    }

    // Parse request body
    const body = await request.json();
    validateRequired(body, ['keyword_id'], locale);

    const { keyword_id } = body;

    // Get keyword from database
    const { data: keyword, error: keywordError } = await (adminSupabase.from('content_keywords') as ReturnType<typeof adminSupabase.from>)
      .select('*')
      .eq('id', keyword_id)
      .single();

    if (keywordError || !keyword) {
      throw new APIError(ErrorCode.NOT_FOUND, 'Keyword not found', { keyword_id }, locale);
    }

    // Check if already generating
    if (keyword.status === 'generating') {
      return createSuccessResponse({
        success: true,
        status: 'already_generating',
        keyword_id,
        message: 'Content generation is already in progress',
      });
    }

    // Update keyword status to 'generating' immediately
    await (adminSupabase.from('content_keywords') as ReturnType<typeof adminSupabase.from>)
      .update({ status: 'generating', updated_at: new Date().toISOString() })
      .eq('id', keyword_id);

    secureLog('info', 'Starting content generation', {
      keywordId: keyword_id,
      keyword: keyword.keyword,
      generatedBy: user.id,
    });

    // Run generation and wait for completion
    // Client polls /api/content/generate-status while this runs
    try {
      const result = await generateContentInBackground(adminSupabase, keyword, user.id);

      return createSuccessResponse({
        success: true,
        status: 'completed',
        keyword_id,
        blog_post_id: result.blogPostId,
        quality_score: result.qualityScore,
        message: 'Content generation completed successfully.',
      });
    } catch (genError) {
      secureLog('error', 'Content generation failed', {
        keywordId: keyword_id,
        error: genError instanceof Error ? genError.message : 'Unknown error',
      });

      // Reset status to pending on error
      await (adminSupabase.from('content_keywords') as ReturnType<typeof adminSupabase.from>)
        .update({ status: 'pending', updated_at: new Date().toISOString() })
        .eq('id', keyword_id);

      throw new APIError(ErrorCode.INTERNAL_ERROR, 'Content generation failed. Please try again.', undefined, locale);
    }
  } catch (error) {
    return createErrorResponse(error);
  }
}

/**
 * Background content generation function
 */
async function generateContentInBackground(
  adminSupabase: Awaited<ReturnType<typeof createAdminClient>>,
  keyword: {
    id: string;
    keyword: string;
    locale: string | null;
    category: string | null;
  },
  userId: string
) {
  const startTime = Date.now();

  try {
    // Generate content
    const pipelineResult = await runContentPipeline({
      keyword: keyword.keyword,
      locale: (keyword.locale as Locale) || 'en',
      category: keyword.category || 'general',
      targetWordCount: 1500,
    });

    const { content, metadata, qualityScore } = pipelineResult;

    // Build blog post data (cover_image_url will be set later by DALL-E)
    const blogPostData: Record<string, unknown> = {
      slug: generateSlug(content.title),
      status: 'draft',
      author_id: userId,
      category: keyword.category || 'medical-tourism',
      tags: content.tags,
      cover_image_url: null, // Will be generated by DALL-E
      generation_metadata: {
        ...metadata,
        qualityScore: qualityScore.overall,
        generatedBy: userId,
        generatedAt: new Date().toISOString(),
        keyword: keyword.keyword,
        sourceLocale: keyword.locale || 'en',
      },
    };

    // Always save to English fields first (required by schema)
    blogPostData['title_en'] = content.title;
    blogPostData['excerpt_en'] = content.excerpt;
    blogPostData['content_en'] = content.content;
    blogPostData['meta_title_en'] = content.metaTitle;
    blogPostData['meta_description_en'] = content.metaDescription;

    // Also save to locale-specific fields if not English
    const primaryLocale = keyword.locale || 'en';
    const dbLocale = DB_LOCALE_MAP[primaryLocale] || 'en';
    if (dbLocale !== 'en') {
      blogPostData[`title_${dbLocale}`] = content.title;
      blogPostData[`excerpt_${dbLocale}`] = content.excerpt;
      blogPostData[`content_${dbLocale}`] = content.content;
      blogPostData[`meta_title_${dbLocale}`] = content.metaTitle;
      blogPostData[`meta_description_${dbLocale}`] = content.metaDescription;
    }

    // Insert blog post
    const { data: insertedPost, error: insertError } = await (adminSupabase.from('blog_posts') as ReturnType<typeof adminSupabase.from>)
      .insert(blogPostData)
      .select()
      .single();

    if (insertError) {
      throw new Error(`Failed to save blog post: ${insertError.message}`);
    }

    // Generate cover image with DALL-E
    secureLog('info', 'Starting DALL-E image generation', {
      blogPostId: insertedPost.id,
      title: content.title,
    });

    try {
      const imageResult = await runImagePipeline(adminSupabase, {
        blogPostId: insertedPost.id,
        title: content.title,
        excerpt: content.excerpt,
        category: keyword.category || 'medical-tourism',
        locale: (keyword.locale as Locale) || 'en',
        keyword: keyword.keyword,
        useSimplePrompt: false,
      });

      if (imageResult.success) {
        secureLog('info', 'DALL-E image generated', {
          blogPostId: insertedPost.id,
          imageUrl: imageResult.imageUrl,
          timeMs: imageResult.timeMs,
        });
      } else {
        // Image generation failed, but content is saved - use fallback
        secureLog('warn', 'DALL-E image generation failed, using fallback', {
          blogPostId: insertedPost.id,
          error: imageResult.error,
        });

        // Set fallback Unsplash image
        const fallbackUrl = getFallbackImageUrl(keyword.category || 'medical-tourism', keyword.keyword);
        await (adminSupabase.from('blog_posts') as ReturnType<typeof adminSupabase.from>)
          .update({ cover_image_url: fallbackUrl })
          .eq('id', insertedPost.id);
      }
    } catch (imageError) {
      // Image generation error - content is still saved, use fallback
      secureLog('error', 'DALL-E image generation error', {
        blogPostId: insertedPost.id,
        error: imageError instanceof Error ? imageError.message : 'Unknown error',
      });

      const fallbackUrl = getFallbackImageUrl(keyword.category || 'medical-tourism', keyword.keyword);
      await (adminSupabase.from('blog_posts') as ReturnType<typeof adminSupabase.from>)
        .update({ cover_image_url: fallbackUrl })
        .eq('id', insertedPost.id);
    }

    // Update keyword with success
    await (adminSupabase.from('content_keywords') as ReturnType<typeof adminSupabase.from>)
      .update({
        blog_post_id: insertedPost.id,
        status: 'generated',
        quality_score: qualityScore.overall,
        updated_at: new Date().toISOString(),
      })
      .eq('id', keyword.id);

    const totalTime = Date.now() - startTime;
    secureLog('info', 'Background generation completed', {
      keywordId: keyword.id,
      blogPostId: insertedPost.id,
      qualityScore: qualityScore.overall,
      totalTimeMs: totalTime,
    });

    return {
      blogPostId: insertedPost.id,
      qualityScore: qualityScore.overall,
    };

  } catch (error) {
    // Update keyword status to failed/pending
    await (adminSupabase.from('content_keywords') as ReturnType<typeof adminSupabase.from>)
      .update({
        status: 'pending', // Reset to pending so user can retry
        updated_at: new Date().toISOString(),
      })
      .eq('id', keyword.id);

    secureLog('error', 'Background generation error', {
      keywordId: keyword.id,
      error: error instanceof Error ? error.message : 'Unknown error',
    });

    throw error;
  }
}

function generateSlug(title: string): string {
  const baseSlug = title
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .substring(0, 50)
    .replace(/^-+|-+$/g, '');

  // Add timestamp to ensure uniqueness
  const timestamp = Date.now().toString(36);
  return `${baseSlug}-${timestamp}`;
}

function getFallbackImageUrl(category: string, keyword: string): string {
  const categoryImages: Record<string, string[]> = {
    'plastic-surgery': [
      'https://images.unsplash.com/photo-1579684385127-1ef15d508118?w=1200&h=630&fit=crop',
      'https://images.unsplash.com/photo-1551601651-2a8555f1a136?w=1200&h=630&fit=crop',
      'https://images.unsplash.com/photo-1629909613654-28e377c37b09?w=1200&h=630&fit=crop',
    ],
    'dermatology': [
      'https://images.unsplash.com/photo-1570172619644-dfd03ed5d881?w=1200&h=630&fit=crop',
      'https://images.unsplash.com/photo-1616394584738-fc6e612e71b9?w=1200&h=630&fit=crop',
    ],
    'dental': [
      'https://images.unsplash.com/photo-1606811841689-23dfddce3e95?w=1200&h=630&fit=crop',
      'https://images.unsplash.com/photo-1588776814546-1ffcf47267a5?w=1200&h=630&fit=crop',
    ],
    'medical-tourism': [
      'https://images.unsplash.com/photo-1576091160550-2173dba999ef?w=1200&h=630&fit=crop',
      'https://images.unsplash.com/photo-1519389950473-47ba0277781c?w=1200&h=630&fit=crop',
    ],
  };

  const images = categoryImages[category] || categoryImages['medical-tourism'];
  const hash = keyword.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
  return images[hash % images.length];
}
